// Generated by CoffeeScript 2.4.1
(function() {
  // Description:
  //   Give or take away points. Keeps track and even prints out graphs.

  // Dependencies:
  //   "underscore": ">= 1.0.0"
  //   "clark": "0.0.6"

  // Configuration:
  //   HUBOT_PLUSPLUS_KEYWORD: the keyword that will make hubot give the
  //   score for a name and the reasons. For example you can set this to
  //   "score|karma" so hubot will answer to both keywords.
  //   If not provided will default to 'score'.

  //   HUBOT_PLUSPLUS_REASON_CONJUNCTIONS: a pipe separated list of conjuntions to
  //   be used when specifying reasons. The default value is
  //   "for|because|cause|cuz|as", so it can be used like:
  //   "foo++ for being awesome" or "foo++ cuz they are awesome".

  // Commands:
  //   <name>++ [<reason>] - Increment score for a name (for a reason)
  //   <name>-- [<reason>] - Decrement score for a name (for a reason)
  //   hubot score <name> - Display the score for a name and some of the reasons
  //   hubot top <amount> - Display the top scoring <amount>
  //   hubot bottom <amount> - Display the bottom scoring <amount>
  //   hubot erase <name> [<reason>] - Remove the score for a name (for a reason)

  // URLs:
  //   /hubot/scores[?name=<name>][&direction=<top|botton>][&limit=<10>]

  // Author:
  //   snehitgajjar
  var ScoreKeeper, _, clark, querystring;

  _ = require('underscore');

  clark = require('clark');

  querystring = require('querystring');

  ScoreKeeper = require('./scorekeeper');

  module.exports = function(robot) {
    var reasonConjunctions, reasonsKeyword, scoreKeeper, scoreKeyword;
    scoreKeeper = new ScoreKeeper(robot);
    scoreKeyword = process.env.HUBOT_PLUSPLUS_KEYWORD || 'score';
    reasonsKeyword = process.env.HUBOT_PLUSPLUS_REASONS || 'raisins';
    reasonConjunctions = process.env.HUBOT_PLUSPLUS_CONJUNCTIONS || 'for|because|cause|cuz|as';
    // sweet regex bro
    // from beginning of line
    // allow for spaces after the thing being upvoted (@user ++)
    // the increment/decrement operator ++ or --
    // optional reason for the plusplus
    robot.hear(/^(.*?(\blol\b)[^$]*)$$/i, function(msg) { // end of line
      var from, lolWord, message, reason, reasonScore, room, score;
      // let's get our local vars in place
      // [dummy, name, operator, reason] = msg.match
      [test, lolWord] = msg.match;
      from = msg.message.user.name.toLowerCase();
      room = msg.message.room;
      console.log(`Hello, ${lolWord} - ${reason}!`);
      // do some sanitizing
      reason = reason != null ? reason.trim().toLowerCase() : void 0;
      // if name
      //   if name.charAt(0) == ':'
      //     name = (name.replace /(^\s*@)|([,\s]*$)/g, '').trim().toLowerCase()
      //   else
      //     name = (name.replace /(^\s*@)|([,:\s]*$)/g, '').trim().toLowerCase()

      // # check whether a name was specified. use MRU if not
      // unless name? && name != ''
      //   [name, lastReason] = scoreKeeper.last(room)
      //   reason = lastReason if !reason? && lastReason?

      // do the {up, down}vote, and figure out what the new score is
      console.log(`Hello, ${lolWord} - ${reason}!`);
      [score, reasonScore] = lolWord.toLowerCase() === "lol" ? scoreKeeper.add(from, room, reason) : void 0;

      console.log(`Hello, ${score} - ${reasonScore}!`);
      // if we got a score, then display all the things and fire off events!
      if (score != null) {
        message = reason != null ? reasonScore === 1 || reasonScore === -1 ? score === 1 || score === -1 ? `${from} has ${score} point for ${reason}.` : `${from} has ${score} points, ${reasonScore} of which is for ${reason}.` : `${from} has ${score} points, ${reasonScore} of which are for ${reason}.` : score === 1 ? `${from} has ${score} point` : `${from} has ${score} points`;
        msg.send(message);
        return robot.emit("plus-one", {
          name: from,
          direction: '++',
          room: room,
          reason: reason,
          from: from
        });
      }
    });
    // thing to be erased
    // optionally erase a reason from thing
    robot.respond(/(?:erase)([\s\w'@.-:\u3040-\u30FF\uFF01-\uFF60\u4E00-\u9FA0]*)(?:\s+(?:for|because|cause|cuz)\s+(.+))?$/i, function(msg) { // eol
      var __, erased, from, isAdmin, message, name, reason, ref, ref1, room, user;
      [__, name, reason] = msg.match;
      from = msg.message.user.name.toLowerCase();
      user = msg.envelope.user;
      room = msg.message.room;
      reason = reason != null ? reason.trim().toLowerCase() : void 0;
      if (name) {
        if (name.charAt(0) === ':') {
          name = (name.replace(/(^\s*@)|([,\s]*$)/g, '')).trim().toLowerCase();
        } else {
          name = (name.replace(/(^\s*@)|([,:\s]*$)/g, '')).trim().toLowerCase();
        }
      }
      isAdmin = ((ref = this.robot.auth) != null ? ref.hasRole(user, 'plusplus-admin') : void 0) || ((ref1 = this.robot.auth) != null ? ref1.hasRole(user, 'admin') : void 0);
      if ((this.robot.auth == null) || isAdmin) {
        erased = scoreKeeper.erase(name, from, room, reason);
      } else {
        return msg.reply("Sorry, you don't have authorization to do that.");
      }
      if (erased != null) {
        message = reason != null ? `Erased the following reason from ${name}: ${reason}` : `Erased points for ${name}`;
        return msg.send(message);
      }
    });
    // Catch the message asking for the score.
    robot.respond(new RegExp("(?:" + scoreKeyword + ") (for\s)?(.*)", "i"), function(msg) {
      var name, reasonString, reasons, score;
      name = msg.match[2].trim().toLowerCase();
      if (name) {
        if (name.charAt(0) === ':') {
          name = name.replace(/(^\s*@)|([,\s]*$)/g, '');
        } else {
          name = name.replace(/(^\s*@)|([,:\s]*$)/g, '');
        }
      }
      console.log(name);
      score = scoreKeeper.scoreForUser(name);
      reasons = scoreKeeper.reasonsForUser(name);
      reasonString = typeof reasons === 'object' && Object.keys(reasons).length > 0 ? `${name} has ${score} points. Here are some ${reasonsKeyword}:` + _.reduce(reasons, function(memo, val, key) {
        return memo += `\n${key}: ${val} points`;
      }, "") : `${name} has ${score} points.`;
      return msg.send(reasonString);
    });
    robot.respond(/(top|bottom) (\d+)/i, function(msg) {
      var amount, graphSize, i, j, message, ref, tops;
      amount = parseInt(msg.match[2]) || 10;
      message = [];
      tops = scoreKeeper[msg.match[1]](amount);
      if (tops.length > 0) {
        for (i = j = 0, ref = tops.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          message.push(`${i + 1}. ${tops[i].name} : ${tops[i].score}`);
        }
      } else {
        message.push("No scores to keep track of yet!");
      }
      if (msg.match[1] === "top") {
        graphSize = Math.min(tops.length, Math.min(amount, 20));
        message.splice(0, 0, clark(_.first(_.pluck(tops, "score"), graphSize)));
      }
      return msg.send(message.join("\n"));
    });
    robot.router.get(`/${robot.name}/normalize-points`, function(req, res) {
      scoreKeeper.normalize(function(score) {
        if (score > 0) {
          score = score - Math.ceil(score / 10);
        } else if (score < 0) {
          score = score - Math.floor(score / 10);
        }
        return score;
      });
      return res.end(JSON.stringify('done'));
    });
    return robot.router.get(`/${robot.name}/scores`, function(req, res) {
      var amount, direction, obj, query, tops;
      query = querystring.parse(req._parsedUrl.query);
      if (query.name) {
        obj = {};
        obj[query.name] = scoreKeeper.scoreForUser(query.name);
        return res.end(JSON.stringify(obj));
      } else {
        direction = query.direction || "top";
        amount = query.limit || 10;
        tops = scoreKeeper[direction](amount);
        return res.end(JSON.stringify(tops, null, 2));
      }
    });
  };

}).call(this);
